# 设计模式重构 - 两人分工方案

## ✅ 是否可以并行开发？

**答案：可以并行开发，但需要遵循接口约定！**

### 并行开发的可行性分析

| 方面 | 状态 | 说明 |
|------|------|------|
| **文件冲突** | ✅ 无冲突 | 两人不会同时修改同一个文件的定义 |
| **接口依赖** | ⚠️ 需协调 | FarmMap使用Crops，但只需保持接口稳定 |
| **编译依赖** | ✅ 可解决 | 通过前向声明和接口约定解决 |
| **功能依赖** | ✅ 独立 | 各模式功能相互独立 |

### 并行开发的关键约定

1. **接口稳定性约定**：
   - B必须保持 `Crops::create()` 等公共接口不变
   - A可以基于稳定接口在FarmMap中使用Crops

2. **开发顺序建议**：
   - **第1周**：B先完成Crops的State模式框架（保持接口），A做Builder模式
   - **第2-4周**：完全并行开发

3. **沟通机制**：
   - 开发前约定接口签名
   - 每天同步进度
   - 接口变更必须提前通知

---

## 📋 分工原则

1. **最小化文件冲突**：确保两人不会同时修改同一个文件
2. **逻辑内聚**：相关模式分配给同一个人，便于理解整体设计
3. **工作量均衡**：两个工作包的工作量尽量接近
4. **依赖隔离**：避免相互依赖，可以并行开发

---

## 👥 分工方案

### 🟦 工作包A：地图系统 + 创建型模式
**负责人：开发者A**

#### 负责的设计模式（4个）：
1. ✅ **Abstract Factory模式** - 地图工厂系统
2. ✅ **Adapter模式** - 地图适配器
3. ✅ **Bridge模式** - 地图抽象与实现分离
4. ✅ **Builder模式** - Animal类构建器

#### 涉及的文件清单：

**新建文件：**
- `Classes/Maps/Factory/MapFactory.h` 和 `.cpp` - 抽象工厂接口
- `Classes/Maps/Factory/FarmMapFactory.h` 和 `.cpp` - 农场地图工厂
- `Classes/Maps/Factory/TownMapFactory.h` 和 `.cpp` - 小镇地图工厂
- `Classes/Maps/Factory/MineMapFactory.h` 和 `.cpp` - 矿洞地图工厂
- `Classes/Maps/Factory/IndoorMapFactory.h` 和 `.cpp` - 室内地图工厂
- `Classes/Maps/Adapter/MapAdapter.h` 和 `.cpp` - 地图适配器接口
- `Classes/Maps/Adapter/FarmMapAdapter.h` 和 `.cpp` - 农场地图适配器
- `Classes/Maps/Adapter/TownMapAdapter.h` 和 `.cpp` - 小镇地图适配器
- `Classes/Maps/Adapter/MineMapAdapter.h` 和 `.cpp` - 矿洞地图适配器
- `Classes/Maps/Adapter/IndoorMapAdapter.h` 和 `.cpp` - 室内地图适配器
- `Classes/Maps/Bridge/MapImplementation.h` 和 `.cpp` - 地图实现接口
- `Classes/Maps/Bridge/FarmMapImplementation.h` 和 `.cpp` - 农场地图实现
- `Classes/Maps/Bridge/TownMapImplementation.h` 和 `.cpp` - 小镇地图实现
- `Classes/Maps/Bridge/MineMapImplementation.h` 和 `.cpp` - 矿洞地图实现
- `Classes/Maps/Bridge/IndoorMapImplementation.h` 和 `.cpp` - 室内地图实现
- `Classes/Animal/AnimalBuilder.h` 和 `.cpp` - Animal构建器

**修改的现有文件：**
- `Classes/Maps/GameMap.h` 和 `.cpp` - 添加Bridge模式支持
- `Classes/Maps/FarmMap.h` 和 `.cpp` - 适配新工厂和Bridge
- `Classes/Maps/TownMap.h` 和 `.cpp` - 适配新工厂和Bridge
- `Classes/Maps/MineMap.h` 和 `.cpp` - 适配新工厂和Bridge
- `Classes/Maps/IndoorMap.h` 和 `.cpp` - 适配新工厂和Bridge
- `Classes/Control/MapSwitchManager.h` 和 `.cpp` - 使用工厂和适配器
- `Classes/Animal/Animal.h` 和 `.cpp` - 添加Builder支持

#### 工作重点：
- 重构地图创建逻辑，使用Abstract Factory替代if-else
- 实现Adapter统一不同地图接口
- 使用Bridge分离地图抽象与实现
- 为Animal类实现Builder模式

---

### 🟩 工作包B：行为型模式 + 额外模式
**负责人：开发者B**

#### 负责的设计模式（3个）：
1. ✅ **State模式** - Crops类状态管理
2. ✅ **Observer模式** - TimeManager观察者系统
3. ⭐ **Strategy模式** - Store类价格策略（额外模式）

#### 涉及的文件清单：

**新建文件：**
- `Classes/Crops/State/CropState.h` 和 `.cpp` - 农作物状态基类
- `Classes/Crops/State/SeedState.h` 和 `.cpp` - 种子状态
- `Classes/Crops/State/SproutingState.h` 和 `.cpp` - 发芽状态
- `Classes/Crops/State/GrowingState.h` 和 `.cpp` - 生长状态
- `Classes/Crops/State/MatureState.h` 和 `.cpp` - 成熟状态
- `Classes/Control/Observer/TimeObserver.h` - 时间观察者接口
- `Classes/Store/Strategy/PricingStrategy.h` 和 `.cpp` - 价格策略接口
- `Classes/Store/Strategy/SeasonalPricingStrategy.h` 和 `.cpp` - 季节价格策略
- `Classes/Store/Strategy/WeatherPricingStrategy.h` 和 `.cpp` - 天气价格策略
- `Classes/Store/Strategy/AffectionPricingStrategy.h` 和 `.cpp` - 好感度价格策略

**修改的现有文件：**
- `Classes/Crops/Crops.h` 和 `.cpp` - 实现State模式
- `Classes/Control/TimeManager.h` 和 `.cpp` - 实现Observer模式（Subject）
- `Classes/Store/Store.h` 和 `.cpp` - 实现Observer接口 + Strategy模式
- `Classes/Character/NPC.h` 和 `.cpp` - 实现Observer接口（响应时间变化）
- `Classes/Control/NpcManager.h` 和 `.cpp` - 注册NPC为观察者

#### 工作重点：
- 重构Crops类，使用State模式管理生长阶段
- 实现TimeManager的Observer模式，通知时间变化
- 为Store实现Strategy模式，封装价格计算逻辑
- 让Store和NPC实现TimeObserver接口

---

## ⚠️ 潜在冲突点及解决方案

### 冲突点1：Crops类
- **工作包A**：FarmMap使用Crops::create()创建农作物（但只使用，不修改Crops类）
- **工作包B**：需要修改Crops类实现State模式
- **解决方案**：✅ **可以并行**
  - B负责修改Crops类的内部实现（State模式）
  - A在FarmMap中只使用Crops的公共接口（create方法）
  - **约定**：B必须保持Crops::create()接口不变，只修改内部实现

### 冲突点2：Store类
- **工作包A**：不涉及Store类
- **工作包B**：需要修改Store类（Observer + Strategy）
- **解决方案**：✅ 无冲突，Store类完全由工作包B负责

### 冲突点3：Animal类
- **工作包A**：需要修改Animal类实现Builder，并在FarmMap中使用
- **工作包B**：不涉及Animal类
- **解决方案**：✅ 无冲突，Animal类完全由工作包A负责

### 冲突点4：TimeManager类
- **工作包A**：不涉及TimeManager
- **工作包B**：需要修改TimeManager实现Observer
- **解决方案**：✅ 无冲突，TimeManager完全由工作包B负责

### 冲突点5：地图相关类
- **工作包A**：需要修改所有地图类（包括FarmMap中使用Animal和Crops）
- **工作包B**：不涉及地图类
- **解决方案**：✅ **可以并行**
  - A负责修改FarmMap，使用Animal和Crops
  - B负责修改Crops的内部实现
  - **约定**：B保持Crops公共接口稳定，A可以正常使用

### ⚠️ 重要协调点

**FarmMap.cpp 同时使用 Animal 和 Crops：**
- `FarmMap.cpp` 第11-12行包含了 `Crops.h` 和 `Animal.h`
- A会在FarmMap中使用这两个类创建对象
- B会修改Crops的内部实现

**并行开发策略：**
1. **先期约定**（开发前1-2天）：
   - B先定义好Crops的公共接口（create方法签名）
   - A可以基于这个接口在FarmMap中使用Crops
   - B再逐步实现State模式的内部逻辑

2. **接口稳定性**：
   - B必须保持 `Crops::create(const std::string& type, int maxGrowthStage)` 接口不变
   - B可以添加新的方法，但不能删除或修改现有公共方法

3. **开发顺序建议**：
   - **第1周**：B先完成Crops的State模式框架（保持create接口），A可以先做Builder模式
   - **第2周**：A开始做地图相关模式，此时Crops接口已稳定
   - **第3-4周**：并行开发，互不干扰

---

## 📅 实施时间线建议

### ⚠️ 重要：开发顺序说明

**关键理解：A改FarmMap时，主要是重构地图创建逻辑（Abstract Factory, Adapter, Bridge），而FarmMap中使用Animal和Crops的部分只是调用接口，只要接口稳定就可以。**

### 第一阶段（第1-2周）
**顺序开发：先稳定接口，再改FarmMap**

#### 第1周：接口稳定期
- **开发者B**：
  1. ✅ **优先完成** State模式（Crops类）
  2. **关键要求**：必须保持以下接口不变：
     - `Crops::create(const std::string& type, int maxGrowthStage)` 
     - `Crops::setPlayerLevel(int level)`
     - `Crops::setGrowthStage(int stage)`
  3. 可以修改内部实现，但公共接口必须稳定

- **开发者A**：
  1. ✅ **优先完成** Builder模式（Animal类）
  2. **关键要求**：必须保持 `Animal::create()` 接口不变（或提供Builder的同时保留create作为兼容）
  3. 可以添加 `AnimalBuilder`，但原有的 `Animal::create()` 应该继续工作

#### 第2周：接口确认 + 开始FarmMap重构
- **开发者A**：
  1. ✅ 确认Animal和Crops接口已稳定（与B沟通）
  2. ✅ 开始重构FarmMap，应用Abstract Factory模式
  3. ✅ 在FarmMap中继续使用 `Animal::create()` 和 `Crops::create()`（接口已稳定）

- **开发者B**：
  1. 开始设计Observer模式接口
  2. 可以继续完善Crops的State模式（只要不改变公共接口）

### 第二阶段（第3-4周）
**完全并行开发**

- **开发者A**：
  1. 完成Abstract Factory模式（所有地图工厂）
  2. 实现Adapter模式（统一地图接口）
  3. 实现Bridge模式（分离抽象与实现）
  4. 更新MapSwitchManager使用新工厂

- **开发者B**：
  1. 完成Observer模式（TimeManager + 观察者注册）
  2. 实现Strategy模式（Store类）
  3. 让Store和NPC实现TimeObserver接口

### 第三阶段（第5周）
**集成测试**

- 两人合并代码
- 解决可能的集成问题
- 测试所有设计模式功能
- 编写文档

---

## 🔑 关键开发顺序总结

```
第1周：
├─ B: 完成Crops的State模式（保持接口稳定）← 优先
└─ A: 完成Animal的Builder模式（保持接口稳定）← 优先

第2周：
├─ A: 确认接口稳定后，开始改FarmMap（使用Abstract Factory）
└─ B: 开始Observer模式设计

第3-4周：
├─ A: 完成地图相关模式（Abstract Factory, Adapter, Bridge）
└─ B: 完成Observer和Strategy模式

第5周：
└─ 集成测试
```

**核心原则：**
1. ✅ B先改完Crops（保持接口稳定）
2. ✅ A先改完Animal（保持接口稳定）  
3. ✅ **然后A再改FarmMap**（此时Animal和Crops接口已稳定，可以安全使用）

---

## 🔄 Git协作流程

### 分支策略
```
main (主分支)
├── feature/design-patterns-map-system (开发者A)
└── feature/design-patterns-behavioral (开发者B)
```

### 提交规范
- **开发者A**：提交信息前缀 `[MapSystem]` 或 `[Builder]`
- **开发者B**：提交信息前缀 `[Behavioral]` 或 `[Observer]` 或 `[Strategy]` 或 `[State]`

### 示例提交信息
```
[MapSystem] 实现Abstract Factory模式 - 创建MapFactory接口
[Builder] 为Animal类添加Builder模式支持
[State] 实现Crops类的State模式 - 创建CropState基类
[Observer] 实现TimeManager的Observer模式
[Strategy] 为Store类实现价格策略模式
```

---

## ✅ 检查清单

### 开发者A检查清单
- [ ] Builder模式：AnimalBuilder类实现完成
- [ ] Abstract Factory：所有地图工厂实现完成
- [ ] Adapter：所有地图适配器实现完成
- [ ] Bridge：地图实现类完成，GameMap使用Bridge模式
- [ ] MapSwitchManager已更新使用新工厂
- [ ] 所有地图类已适配新模式
- [ ] 代码编译通过
- [ ] 功能测试通过

### 开发者B检查清单
- [ ] State模式：所有CropState子类实现完成
- [ ] Crops类已重构使用State模式
- [ ] Observer模式：TimeObserver接口定义完成
- [ ] TimeManager实现Subject功能
- [ ] Store实现TimeObserver接口
- [ ] NPC实现TimeObserver接口
- [ ] Strategy模式：所有价格策略实现完成
- [ ] Store类已重构使用Strategy模式
- [ ] 代码编译通过
- [ ] 功能测试通过

---

## 📝 注意事项

1. **沟通协调**：
   - 每天同步进度，避免理解偏差
   - 遇到接口设计问题及时讨论
   - 重大架构决策需要双方确认

2. **代码规范**：
   - 保持代码风格一致
   - 添加必要的注释说明设计模式应用
   - 遵循项目现有的命名规范

3. **测试策略**：
   - 每个模式实现后立即测试
   - 保持向后兼容，不破坏现有功能
   - 集成前确保各自代码稳定

4. **文档更新**：
   - 及时更新设计模式重构方案文档
   - 记录设计决策和遇到的问题
   - 为最终报告准备材料

---

## 🎯 成功标准

- ✅ 所有6个设计模式（5个课程模式 + 1个额外模式）成功实现
- ✅ 代码编译无错误，功能正常运行
- ✅ 两人工作无冲突，顺利合并
- ✅ 代码质量提升，可维护性增强
- ✅ 设计模式应用合理，符合最佳实践

