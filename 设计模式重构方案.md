# 星露谷物语项目 - 设计模式重构方案

## 项目概述
本项目是一个基于Cocos2d-x 3.17.2开发的星露谷物语游戏，包含角色系统、地图系统、NPC系统、商店系统、农作物系统、动物系统等。

## 设计模式应用方案

### 1. Builder模式（创建型模式）✅
**应用位置：** `Classes/Animal/Animal.h` 和 `Classes/Animal/Animal.cpp`

**重构原因：**
- Animal类的创建需要多个参数（类型、位置、好感度、喂食状态等）
- 当前使用静态`create`方法，参数较多且不够灵活
- Builder模式可以逐步构建复杂对象，提高代码可读性和可维护性

**重构方案：**
- 创建`AnimalBuilder`类
- 提供链式调用来设置动物属性
- 支持可选参数和默认值

**示例代码结构：**
```cpp
class AnimalBuilder {
public:
    AnimalBuilder& setType(const std::string& type);
    AnimalBuilder& setPosition(const Vec2& position);
    AnimalBuilder& setAffection(float affection);
    AnimalBuilder& setAreaSize(float size);
    Animal* build();
};
```

---

### 2. Abstract Factory模式（创建型模式）✅
**应用位置：** `Classes/Maps/` 目录下的地图系统

**重构原因：**
- 存在多种地图类型（FarmMap, TownMap, MineMap, IndoorMap）
- 每种地图需要创建不同的相关对象（动物、NPC、作物等）
- 当前在`MapSwitchManager`中使用if-else判断创建，不符合开闭原则

**重构方案：**
- 创建`MapFactory`抽象工厂接口
- 为每种地图类型创建具体工厂（`FarmMapFactory`, `TownMapFactory`等）
- 每个工厂负责创建对应地图及其相关对象

**示例代码结构：**
```cpp
class MapFactory {
public:
    virtual GameMap* createMap(const std::string& mapFile, const Vec2& position) = 0;
    virtual std::vector<Animal*> createAnimals() = 0;
    virtual std::vector<NPC*> createNPCs() = 0;
};

class FarmMapFactory : public MapFactory {
    // 实现农场地图相关对象的创建
};
```

---

### 3. Adapter模式（结构型模式）✅
**应用位置：** `Classes/Maps/GameMap.h` 和其子类

**重构原因：**
- 不同地图类型（FarmMap, TownMap, MineMap）有不同的初始化接口
- `MapSwitchManager`需要统一处理不同类型的地图
- 需要适配不同地图类型的接口差异

**重构方案：**
- 创建`MapAdapter`类，统一不同地图类型的接口
- 适配器封装不同地图的创建和初始化逻辑
- 简化`MapSwitchManager`中的地图切换逻辑

**示例代码结构：**
```cpp
class MapAdapter {
public:
    virtual GameMap* createAndInit(const std::string& mapFile, const Vec2& position, void* additionalParams) = 0;
    virtual Vec2 getTeleportPosition() = 0;
};

class FarmMapAdapter : public MapAdapter {
    // 适配FarmMap的特殊创建逻辑
};
```

---

### 4. Bridge模式（结构型模式）✅
**应用位置：** `Classes/Maps/GameMap.h` 及其实现

**重构原因：**
- 地图的抽象（GameMap）与具体实现（FarmMap, TownMap等）耦合
- 地图的渲染逻辑与地图数据逻辑混合
- Bridge模式可以分离抽象与实现，使它们可以独立变化

**重构方案：**
- 创建`MapImplementation`接口，定义地图的实现操作
- `GameMap`作为抽象类，持有`MapImplementation`的引用
- 具体实现类（`FarmMapImplementation`, `TownMapImplementation`）实现具体逻辑

**示例代码结构：**
```cpp
class MapImplementation {
public:
    virtual void loadMapData(const std::string& mapFile) = 0;
    virtual void initializeSpecialFeatures() = 0;
};

class GameMap {
protected:
    MapImplementation* _implementation;
public:
    GameMap(MapImplementation* impl) : _implementation(impl) {}
};
```

---

### 5. State模式（行为型模式）✅
**应用位置：** `Classes/Crops/Crops.h` 和 `Classes/Crops/Crops.cpp`

**重构原因：**
- 农作物有多个生长阶段（种子、发芽、生长、成熟等）
- 每个阶段有不同的行为和属性
- 当前使用`_growthStage`整数表示状态，状态转换逻辑分散

**重构方案：**
- 创建`CropState`抽象状态类
- 实现具体状态类：`SeedState`, `SproutingState`, `GrowingState`, `MatureState`
- `Crops`类持有当前状态对象，通过状态对象处理行为

**示例代码结构：**
```cpp
class CropState {
public:
    virtual void update(Crops* crop, float deltaTime) = 0;
    virtual void water(Crops* crop) = 0;
    virtual bool canHarvest() const = 0;
};

class GrowingState : public CropState {
    // 实现生长状态的行为
};
```

---

### 6. Observer模式（行为型模式）✅
**应用位置：** `Classes/Control/TimeManager.h` 和相关系统

**重构原因：**
- `TimeManager`管理游戏时间，多个系统需要响应时间变化
- 商店需要在新的一天刷新商品
- NPC需要根据时间改变行为
- 当前缺少统一的通知机制

**重构方案：**
- `TimeManager`作为Subject（被观察者）
- 创建`TimeObserver`接口
- `Store`, `NPC`, `Crops`等实现`TimeObserver`接口
- 当时间变化时，`TimeManager`通知所有观察者

**示例代码结构：**
```cpp
class TimeObserver {
public:
    virtual void onDayChanged(int day) = 0;
    virtual void onSeasonChanged(Season season) = 0;
    virtual void onTimeChanged(int hour, int minute) = 0;
};

class TimeManager {
private:
    std::vector<TimeObserver*> _observers;
public:
    void attach(TimeObserver* observer);
    void notifyDayChanged(int day);
};
```

---

### 7. Strategy模式（额外模式 - 未在课程中介绍）⭐
**应用位置：** `Classes/Store/Store.h` 和 `Classes/Store/Store.cpp`

**重构原因：**
- 商店价格计算逻辑可能因季节、天气、好感度等因素变化
- 当前价格更新逻辑可能集中在`updatePrices()`方法中
- Strategy模式可以将不同的价格计算策略封装，便于扩展

**重构方案：**
- 创建`PricingStrategy`接口
- 实现具体策略：`SeasonalPricingStrategy`, `WeatherPricingStrategy`, `AffectionPricingStrategy`
- `Store`类持有价格策略，可以动态切换策略

**示例代码结构：**
```cpp
class PricingStrategy {
public:
    virtual int calculatePrice(const ProductNode& product, const GameContext& context) = 0;
};

class SeasonalPricingStrategy : public PricingStrategy {
    // 根据季节计算价格
};

class Store {
private:
    PricingStrategy* _pricingStrategy;
public:
    void setPricingStrategy(PricingStrategy* strategy);
    int getProductPrice(int index);
};
```

---

## 重构优先级和实施步骤

### 第一阶段：创建型和结构型模式
1. **Builder模式** - Animal类重构（相对独立，影响范围小）
2. **Abstract Factory模式** - 地图工厂系统重构
3. **Adapter模式** - 地图适配器重构
4. **Bridge模式** - 地图抽象与实现分离

### 第二阶段：行为型模式
5. **State模式** - 农作物状态系统重构
6. **Observer模式** - 时间管理系统重构
7. **Strategy模式** - 商店价格策略重构

## 预期收益

1. **代码可维护性提升**：各模式使代码结构更清晰，职责分离更明确
2. **扩展性增强**：新增地图类型、农作物状态、价格策略等更容易
3. **代码复用**：通过工厂、适配器等模式减少重复代码
4. **测试友好**：各模式使单元测试更容易编写

## 注意事项

1. 重构过程中需要保持现有功能不变
2. 逐步重构，每次重构一个模式，充分测试
3. 保持向后兼容，避免破坏现有接口
4. 添加适当的注释和文档说明设计模式的应用

